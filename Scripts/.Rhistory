source("Scripts/Modify_dataset/import_dataset.R")
library(gridExtra)
library(grid)
# AIM1: freq dist per each rank --> nb of c,v,m,b, nuts, and sum of buds --------
max=max(shoot$node)
freq.rank=as.data.frame(seq(1:max))
for (i in 1:max) {
freq.rank[i,"nb_shoots"]=length(shoot[shoot$node==i,"node"])
}
freq.rank=as.matrix(freq.rank)
print(freq.rank)
summary(shoot)
26+25+28+25
names(shoot)
table(shoot$Tree~shoot$shoot_ID)
table(shoot$Tree,shoot$shoot_ID)
table(shoot$Tree,shoot$Tree)
38+35+31
104/3
#AIM: probability of having a sylleptic shoot on that rank
#data: DERUTA 2020
#PhD: Francesca Grisafi
source("Scripts/Modify_dataset/import_dataset.R")
met
View(met.proleptic)
View(met)
View(met)
View(MV.bud.PRO)
View(met)
View(met.proleptic)
source("Scripts/Modify_dataset/import_dataset.R")
TOT = bud[bud$fate == "M", ]
View(TOT)
View(bud)
TOT
names(TOT)
#AIM1: how many nuts in Very long shoots per rank
#AIM2: relationship between average lenght new glomerul and number of nuts and ye per rank node
#data:deruta 2020
#PhD: Francesca Grisafi
source("Scripts/Modify_dataset/import_dataset.R")
library(RColorBrewer)
#glomerule is the new shoots from M buds
glom=bud.proleptic[bud.proleptic$fate=="M",]
glom=glom[c("shoot_ID","Length","class","rank_node","fate","nu","cl","length2yo.cm.")]
# AIM1: how many nuts in Very long shoots per rank ------------------------
plot(glom$nu~glom$class)
V_long = glom[glom$class == "VLo", ]
#fare una tabella con_ numero di nocciole, numero di fiori M e numero di nuovi germogli
df = bud[0, 0]
nliner = unique(sort(V_long$rank_node))
for (rank in nliner) {
P = V_long[V_long$rank_node == rank, ]
n_sh = length(unique(P$shoot_ID))#number shoots
n_m = length(P$fate)#number mixed buds
n_nuts = sum(P$nu)#number nuts
n_cls = sum(P$cl)#number clusters
allegagione = n_cls / n_m#allegagione
nut_set = (n_nuts / n_m)*100#nut set
df = rbind(df,
cbind(rank, n_sh, n_m, n_cls, allegagione, n_nuts, nut_set))
}
df
# AIM2: relationship between average lenght new glomerul and numbe --------
plot(glom$nu~glom$length2yo.cm.)
freq_glom = bud[0, 0]
nliner = unique(sort(glom$rank_node))
for (rank in nliner) {
P = glom[glom$rank_node == rank, ]
n_sh = length(unique(P$shoot_ID))#number shoots
n_m = length(P$fate)#number mixed buds
n_nuts = sum(P$nu)#number nuts
n_cls = sum(P$cl)#number clusters
allegagione = n_cls / n_m#allegagione
nut_set = (n_nuts / n_m)*100#nut set
av_len = mean(P$length2yo.cm.,na.rm = T)
se_len = sd(P$length2yo.cm.,na.rm = T)/sqrt(length(P$length2yo.cm.))
freq_glom = rbind(freq_glom,
cbind(rank, n_sh, n_m, n_nuts, n_cls,allegagione, nut_set, av_len, se_len))
}
freq_glom
#AIM1: relationship between nuts and other parameters
#AIM2: how many nuts in Very long shoots per rank
#AIM3: relationship between average lenght new glomerul and number of nuts and ye per rank node
#data:deruta 2020
#PhD: Francesca Grisafi
source("Scripts/Modify_dataset/import_dataset.R")
library(RColorBrewer)
tot=bud[bud$fate == "M", ]
# AIM1: relationship between nuts and other parameters
names(tot)
View(tot)
plot(tot$nu~tot$Length)
plot(tot$nu~tot$class)
plot(tot$nu~tot$Length.node.)
plot(tot$nu~tot$median_distance)
plot(tot$nu~tot$normal_distance)
plot(tot$nu~tot$distance_abs)
plot(tot$nu~tot$siblings_mv)
plot(tot$nu~tot$shoot_type)
plot(tot$nu~tot$length2yo.cm.)
source("Scripts/Modify_dataset/import_dataset.R")
# library(stats)
# library(dplyr)
# library(RColorBrewer)
# library(plotrix)
# library(plyr)
# library(nnet)
# library(effects)
# library(plotfunctions)
TOT = bud[bud$fate == "M", ]
#model1:
glm_box1 = glm(
nu ~ Length + Length.node. + rank_node + distance_abs + median_distance + siblings_mv + shoot_type + length2yo.cm.+normal_distance+,
data = TOT,
family = "poisson"
)
#model1:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + distance_abs + median_distance + siblings_mv + shoot_type + length2yo.cm.+ normal_distance+,
data = TOT,
family = "poisson")
# library(stats)
# library(dplyr)
# library(RColorBrewer)
# library(plotrix)
# library(plyr)
library(nnet)
#model1:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + distance_abs + median_distance + siblings_mv + shoot_type + length2yo.cm.+ normal_distance+,
data = TOT,
family = "poisson")
#model1:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + distance_abs + median_distance + siblings_mv + shoot_type + length2yo.cm.+ normal_distance,
data = TOT,
family = "poisson")
summary(glm_box1)#remove from_
#model2:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + distance_abs + siblings_mv + shoot_type + length2yo.cm.+ normal_distance,
data = TOT,
family = "poisson")
summary(glm_box1)
#model3:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + siblings_mv + shoot_type + length2yo.cm.+ normal_distance,
data = TOT,
family = "poisson")
summary(glm_box1)
#model4:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + siblings_mv + length2yo.cm.+ normal_distance,
data = TOT,
family = "poisson")
summary(glm_box1)
#model1:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + siblings_mv + shoot_type + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model2:
glm_box1 = glm(nu ~ Length + Length.node. + rank_node + siblings_mv + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model1:
glm_box1 = glm(nu ~ Length + rank_node + siblings_mv + shoot_type + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model2:
glm_box1 = glm(nu ~ Length + rank_node + siblings_mv + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model2:
glm_box1 = glm(nu ~ Length + siblings_mv + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model3:
glm_box1 = glm(nu ~ Length + siblings_mv,
data = TOT,
family = "poisson")
summary(glm_box1)
#real data
summary(TOT$siblings_mv)
a = 0
b = 2
c = 4
d = 6
for (i in 1:nline) {
if (TOT[i, "siblings"] == a) {
TOT[i, "class_siblings"] = "0"
}
if (TOT[i, "siblings"] > a &
TOT[i, "siblings"] <= b) {
TOT[i, "class_siblings"] = "2"
}
if (TOT[i, "siblings"] > b &
TOT[i, "siblings"] <= c) {
TOT[i, "class_siblings"] = "4"
}
if (TOT[i, "siblings"] > c &
TOT[i, "siblings"] <= d) {
TOT[i, "class_siblings"] = "6"
}
if (TOT[i, "siblings"] > d) {
TOT[i, "class_siblings"] = "8"
}
}
a = 0
b = 2
c = 4
d = 6
for (i in 1:nline) {
if (TOT[i, "siblings_mv"] == a) {
TOT[i, "class_siblings"] = "0"
}
if (TOT[i, "siblings_mv"] > a &
TOT[i, "siblings_mv"] <= b) {
TOT[i, "class_siblings"] = "2"
}
if (TOT[i, "siblings_mv"] > b &
TOT[i, "siblings_mv"] <= c) {
TOT[i, "class_siblings"] = "4"
}
if (TOT[i, "siblings_mv"] > c &
TOT[i, "siblings_mv"] <= d) {
TOT[i, "class_siblings"] = "6"
}
if (TOT[i, "siblings_mv"] > d) {
TOT[i, "class_siblings"] = "8"
}
}
#real data
summary(TOT$siblings_mv)
nline = dim(TOT)[1]
a = 0
b = 2
c = 4
d = 6
for (i in 1:nline) {
if (TOT[i, "siblings_mv"] == a) {
TOT[i, "class_siblings"] = "0"
}
if (TOT[i, "siblings_mv"] > a &
TOT[i, "siblings_mv"] <= b) {
TOT[i, "class_siblings"] = "2"
}
if (TOT[i, "siblings_mv"] > b &
TOT[i, "siblings_mv"] <= c) {
TOT[i, "class_siblings"] = "4"
}
if (TOT[i, "siblings_mv"] > c &
TOT[i, "siblings_mv"] <= d) {
TOT[i, "class_siblings"] = "6"
}
if (TOT[i, "siblings_mv"] > d) {
TOT[i, "class_siblings"] = "8"
}
}
TOT$class_siblings = as.factor(TOT$class_siblings)
#mean of values with the same length
mean.freq = TOT[0, 0]
for (i in unique(sort(TOT$Length))) {
Length = i
df = TOT[TOT$Length == Length, ]
for (j in df$class_siblings) {
sib = j
DF = df[df$class_siblings == j, ]
nuts = mean(DF$nu)
se = std.error(DF$nu)
mean.freq = rbind(mean.freq, cbind(Length, sib, nuts, se))
}
}
for (i in unique(sort(TOT$Length))) {
Length = i
df = TOT[TOT$Length == Length, ]
for (j in df$class_siblings) {
sib = j
DF = df[df$class_siblings == j, ]
nuts = mean(DF$nu)
se = sd(DF$nu)/sqrt(length(DF$nu))
mean.freq = rbind(mean.freq, cbind(Length, sib, nuts, se))
}
}
str(mean.freq)
mean.freq$sib = as.factor(mean.freq$sib)
mean.freq[c(1,3:4)]=lapply(mean.freq[c(1,3:4)], as.numeric)
str(mean.freq)
#create a sequence with random numbers between 1 and maximum siblings
summary(TOT$siblings)
for (j in seq(0, 8, 2)) {
mean.freq = cbind(mean.freq, j)
}
names(mean.freq)
#rename columns
colnames(mean.freq)[5:9] = "siblings_mv"
conf_int = mean.freq
#predict model
for (i in grep("siblings_mv", colnames(mean.freq))) {
pred = predict(glm_box1,
newdata = mean.freq[c(1, i)],
type = "response",
se.fit = T)
mean.freq = cbind(mean.freq, pred$fit)
}
#rename columns
names(mean.freq)
colnames(mean.freq)[10:14] = seq(0, 8, 2)
#remove negative values
dupli = mean.freq[10:14]
dupli[dupli < 0] = NA
mean.freq[10:14] = dupli
#confidence intervel
for (i in grep("siblings_mv", colnames(mean.freq))) {
pred = predict(glm_box1,
newdata = mean.freq[c(1, i)],
type = "response",
se.fit = T)
lw = pred$fit + qnorm(0.025) * pred$se.fit
up = pred$fit + qnorm(0.975) * pred$se.fit
lim = as.data.frame(cbind(lw, up))
conf_int = cbind(conf_int, lim)
}
#remove negative values
dupl = conf_int[c(10:19)]
dupl[dupl < 0] = 0
conf_int[c(10:19)] = dupl
rbPal <- brewer.pal(n=6, name="Set1")
source("Scripts/Modify_dataset/import_dataset.R")
# library(plotrix)
# library(plyr)
library(nnet)
TOT = bud[bud$fate == "M", ]
#model1:
glm_box1 = glm(nu ~ Length + rank_node + siblings_mv + shoot_type + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model2:
glm_box1 = glm(nu ~ Length + rank_node + siblings_mv + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#model3:
glm_box1 = glm(nu ~ Length + siblings_mv + length2yo.cm.,
data = TOT,
family = "poisson")
summary(glm_box1)
#FINAL MODEL:
glm_box1 = glm(nu ~ Length + siblings_mv,
data = TOT,
family = "poisson")
summary(glm_box1)
#real data
summary(TOT$siblings_mv)
nline = dim(TOT)[1]
a = 0
b = 2
c = 4
d = 6
for (i in 1:nline) {
if (TOT[i, "siblings_mv"] == a) {
TOT[i, "class_siblings"] = "0"
}
if (TOT[i, "siblings_mv"] > a &
TOT[i, "siblings_mv"] <= b) {
TOT[i, "class_siblings"] = "2"
}
if (TOT[i, "siblings_mv"] > b &
TOT[i, "siblings_mv"] <= c) {
TOT[i, "class_siblings"] = "4"
}
if (TOT[i, "siblings_mv"] > c &
TOT[i, "siblings_mv"] <= d) {
TOT[i, "class_siblings"] = "6"
}
if (TOT[i, "siblings_mv"] > d) {
TOT[i, "class_siblings"] = "8"
}
}
TOT$class_siblings = as.factor(TOT$class_siblings)
#mean of values with the same length
mean.freq = TOT[0, 0]
for (i in unique(sort(TOT$Length))) {
Length = i
df = TOT[TOT$Length == Length, ]
for (j in df$class_siblings) {
sib = j
DF = df[df$class_siblings == j, ]
nuts = mean(DF$nu)
se = sd(DF$nu)/sqrt(length(DF$nu))
mean.freq = rbind(mean.freq, cbind(Length, sib, nuts, se))
}
}
str(mean.freq)
mean.freq$sib = as.factor(mean.freq$sib)
mean.freq[c(1,3:4)]=lapply(mean.freq[c(1,3:4)], as.numeric)
#create a sequence with random numbers between 1 and maximum siblings
summary(TOT$siblings)
for (j in seq(0, 8, 2)) {
mean.freq = cbind(mean.freq, j)
}
names(mean.freq)
#rename columns
colnames(mean.freq)[5:9] = "siblings_mv"
conf_int = mean.freq
#predict model
for (i in grep("siblings_mv", colnames(mean.freq))) {
pred = predict(glm_box1,
newdata = mean.freq[c(1, i)],
type = "response",
se.fit = T)
mean.freq = cbind(mean.freq, pred$fit)
}
#rename columns
names(mean.freq)
colnames(mean.freq)[10:14] = seq(0, 8, 2)
#remove negative values
dupli = mean.freq[10:14]
dupli[dupli < 0] = NA
mean.freq[10:14] = dupli
#confidence intervel
for (i in grep("siblings_mv", colnames(mean.freq))) {
pred = predict(glm_box1,
newdata = mean.freq[c(1, i)],
type = "response",
se.fit = T)
lw = pred$fit + qnorm(0.025) * pred$se.fit
up = pred$fit + qnorm(0.975) * pred$se.fit
lim = as.data.frame(cbind(lw, up))
conf_int = cbind(conf_int, lim)
}
#remove negative values
dupl = conf_int[c(10:19)]
dupl[dupl < 0] = 0
conf_int[c(10:19)] = dupl
rbPal <- brewer.pal(n=6, name="Set1")
transp<-alphaPalette(rbPal, rep(0.25,6))
# library(stats)
# library(dplyr)
library(RColorBrewer)
rbPal <- brewer.pal(n=6, name="Set1")
transp<-alphaPalette(rbPal, rep(0.25,6))
??alphaPalette
# library(effects)
library(plotfunctions)
rbPal <- brewer.pal(n=6, name="Set1")
transp<-alphaPalette(rbPal, rep(0.25,6))
par(mfrow=c(1,1))
par(mar=c(5,4,1,0)+0.1)
#real data
with(mean.freq,plot(nuts~Length,
ylab = "number of nuts",
xlab = "parent length(cm)",
ylim=c(0,5),
col=rbPal[mean.freq$sib],
pch=20,cex=2,
xlim=c(0,72)))
for (i in 1:length((mean.freq)[10:13])) {
t=colnames(mean.freq)[10:13][i]
with(mean.freq,lines(mean.freq[,t]~mean.freq$Length,col=rbPal[i], lwd=3))
}
for (i in 1:length(grep("lw", colnames(conf_int)))) {
j=grep("lw", colnames(conf_int))[i]
t_lw=j
t_up=j+1
with(conf_int[c(1,t_lw:t_up)], polygon(x=c(rev(conf_int$Length),conf_int$Length),
y=c(rev(lw),up),
col=transp[i], border = NA))
}
legend("top",
horiz=T,
title="number of sibling buds",
xpd = TRUE,
legend = c(seq(0,8,2)),
fill = rbPal[1:6],
cex=1)
png("Outputs/Plots/7:nb_nuts.png",width=1200, height=900, res=150)# save plot
rbPal <- brewer.pal(n=6, name="Set1")
transp<-alphaPalette(rbPal, rep(0.25,6))
par(mfrow=c(1,1))
par(mar=c(5,4,1,0)+0.1)
#real data
with(mean.freq,plot(nuts~Length,
ylab = "number of nuts",
xlab = "parent length(cm)",
ylim=c(0,5),
col=rbPal[mean.freq$sib],
pch=20,cex=2,
xlim=c(0,72)))
for (i in 1:length((mean.freq)[10:13])) {
t=colnames(mean.freq)[10:13][i]
with(mean.freq,lines(mean.freq[,t]~mean.freq$Length,col=rbPal[i], lwd=3))
}
for (i in 1:length(grep("lw", colnames(conf_int)))) {
j=grep("lw", colnames(conf_int))[i]
t_lw=j
t_up=j+1
with(conf_int[c(1,t_lw:t_up)], polygon(x=c(rev(conf_int$Length),conf_int$Length),
y=c(rev(lw),up),
col=transp[i], border = NA))
}
legend("top",
horiz=T,
title="number of sibling buds",
xpd = TRUE,
legend = c(seq(0,8,2)),
fill = rbPal[1:6],
cex=1)
dev.off()
glm_box1
summary(glm_box1)
View(TOT)

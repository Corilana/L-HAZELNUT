library(gridExtra);library(grid);library(data.table)
source("Own_rooted_young/Scripts/Modify_dataset/import_dataset_OR.R")
#AIM1:create a metamer level dataset
#AIM2: type of shoot (SYLLEPTIC or PROLEPTIC) where the metamer comes from
#AIM3:save a dataframe, at the metamer level, with just the shoots that were found in 2021
#author: Francesca Grisafi
#year: 2022
library(janitor);library(readxl);library(dplyr);library(plyr)
source("Own_rooted_young/Scripts/Modify_dataset/1_create_shootlevel_OR.R")
new_shoots = read_excel("../../Data/2021Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "2021DFAUTO")
new_shoots = read_excel("../Data/2021Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "2021DFAUTO")
shoot = read_excel("Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
shoot = read_excel("/Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
shoot = read_excel("../Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
dirname(getwd())
shoot = read_excel("L-HAZELNUT/Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
shoot = read_excel("L-HAZELNUT/Own_rooted_young/Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
shoot = read_excel("C:/Users/franc/Desktop/Ricerca/Progetti/L-HAZELNUT/L-HAZELNUT/Own_rooted_young/Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
shoot=data.frame(shoot)
str(shoot)
shoot$class=factor(shoot$class,levels = c("Sh","Me","Lo","VLo"))
names(shoot)
source("C:/Users/franc/Desktop/Ricerca/Progetti/L-HAZELNUT/L-HAZELNUT/Own_rooted_young/Scripts/Modify_dataset/1_create_shootlevel_OR.R")
source("C:/Users/franc/Desktop/Ricerca/Progetti/L-HAZELNUT/L-HAZELNUT/Own_rooted_young/Scripts/Modify_dataset/1_create_shootlevel_OR.R")
new_shoots = read_excel("../Data/2021Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "2021DFAUTO")
new_shoots = read_excel("C:/Users/franc/Desktop/Ricerca/Progetti/L-HAZELNUT/L-HAZELNUT/Own_rooted_young/Data/2021Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "2021DFAUTO")
new_shoots=data.frame(new_shoots)
str(new_shoots)
new_shoots$class=factor(new_shoots$class,levels = c("Sh","Me","Lo","VLo"))
names(new_shoots)
names(new_shoots)[c(18:24)]=c("nb_nodes_new", "c_new", "v_new", "m_new", "cic_new", "cl_new", "b_new")
new_shoots = dplyr::mutate(new_shoots, "tot_buds_m+v+b+c" = NA, .after = b_new)
new_shoots = dplyr::mutate(new_shoots, "nu_new" = NA, .after = cl_new)
new_shoots[new_shoots$length2yo==0, "length2yo"] = NA
start_col = grep("x2y_o_node$", colnames(new_shoots))
colnames(new_shoots)
for (i in 1:nline) {
df = droplevels(new_shoots[i,])
nb_nodes = NA
nb_c = NA
nb_v = NA
nb_m = NA
nb_cl = NA
nb_nu = NA
nb_b = NA
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
for (j in 1:rep) {
dt = df[start_col:fin_col]
if (!is.na(dt[1])){
nb_nodes = sum(nb_nodes , 1, na.rm = T)
}
if (!is.na(dt[2])) {
if (dt[2]==0){
nb_c = sum(nb_c, as.numeric(dt[2]), na.rm = T)
nb_v = sum(nb_v, as.numeric(dt[3]), na.rm = T)
nb_m = sum(nb_m, as.numeric(dt[4]), na.rm = T)
nb_cl = sum(nb_cl, as.numeric(dt[6]), na.rm = T)
nb_nu = sum(nb_nu, as.numeric(dt[7]), na.rm = T)
nb_b = sum(nb_b, as.numeric(dt[8]), na.rm = T)
}
if (dt[2]>0) {
nb_c = sum(nb_c, length(dt[2]), na.rm = T)
}
}
new_shoots[i,c("nb_nodes_new","c_new","v_new","m_new","cl_new","nu_new","b_new")]=c(nb_nodes, nb_c,nb_v,nb_m,nb_cl,nb_nu,nb_b)
start_col = fin_col + 1
fin_col = start_col + (len_col-1)
}
new_shoots[i, "tot_buds_m+v+b+c"] = sum(new_shoots[i, "c_new"],new_shoots[i, "v_new"],
new_shoots[i, "m_new"],new_shoots[i, "b_new"], na.rm = T)#sum of obs
}
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
len_col = (fin_col-start_col)+1
#making the sum of nodes, #catkins,mixed,veg,blind,nuts,cluster per new_shoots
nline = length(new_shoots$shoot1yo)
rep = (ncol(new_shoots)-(start_col-1))/len_col
for (i in 1:nline) {
df = droplevels(new_shoots[i,])
nb_nodes = NA
nb_c = NA
nb_v = NA
nb_m = NA
nb_cl = NA
nb_nu = NA
nb_b = NA
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
for (j in 1:rep) {
dt = df[start_col:fin_col]
if (!is.na(dt[1])){
nb_nodes = sum(nb_nodes , 1, na.rm = T)
}
if (!is.na(dt[2])) {
if (dt[2]==0){
nb_c = sum(nb_c, as.numeric(dt[2]), na.rm = T)
nb_v = sum(nb_v, as.numeric(dt[3]), na.rm = T)
nb_m = sum(nb_m, as.numeric(dt[4]), na.rm = T)
nb_cl = sum(nb_cl, as.numeric(dt[6]), na.rm = T)
nb_nu = sum(nb_nu, as.numeric(dt[7]), na.rm = T)
nb_b = sum(nb_b, as.numeric(dt[8]), na.rm = T)
}
if (dt[2]>0) {
nb_c = sum(nb_c, length(dt[2]), na.rm = T)
}
}
new_shoots[i,c("nb_nodes_new","c_new","v_new","m_new","cl_new","nu_new","b_new")]=c(nb_nodes, nb_c,nb_v,nb_m,nb_cl,nb_nu,nb_b)
start_col = fin_col + 1
fin_col = start_col + (len_col-1)
}
new_shoots[i, "tot_buds_m+v+b+c"] = sum(new_shoots[i, "c_new"],new_shoots[i, "v_new"],
new_shoots[i, "m_new"],new_shoots[i, "b_new"], na.rm = T)#sum of obs
}
str(new_shoots)
new_shoots
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
len_col = (fin_col-start_col)+1
start_col
fin_col
len_col
for (i in 1:nline) {
df = droplevels(new_shoots[i,])
nb_nodes = NA
nb_c = NA
nb_v = NA
nb_m = NA
nb_cl = NA
nb_nu = NA
nb_b = NA
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
for (j in 1:rep) {
dt = df[start_col:fin_col]
print(dt)
if (!is.na(dt[1])){
nb_nodes = sum(nb_nodes , 1, na.rm = T)
}
if (!is.na(dt[2])) {
if (dt[2]==0){
nb_c = sum(nb_c, as.numeric(dt[2]), na.rm = T)
nb_v = sum(nb_v, as.numeric(dt[3]), na.rm = T)
nb_m = sum(nb_m, as.numeric(dt[4]), na.rm = T)
nb_cl = sum(nb_cl, as.numeric(dt[6]), na.rm = T)
nb_nu = sum(nb_nu, as.numeric(dt[7]), na.rm = T)
nb_b = sum(nb_b, as.numeric(dt[8]), na.rm = T)
}
if (dt[2]>0) {
nb_c = sum(nb_c, length(dt[2]), na.rm = T)
}
}
new_shoots[i,c("nb_nodes_new","c_new","v_new","m_new","cl_new","nu_new","b_new")]=c(nb_nodes, nb_c,nb_v,nb_m,nb_cl,nb_nu,nb_b)
start_col = fin_col + 1
fin_col = start_col + (len_col-1)
}
new_shoots[i, "tot_buds_m+v+b+c"] = sum(new_shoots[i, "c_new"],new_shoots[i, "v_new"],
new_shoots[i, "m_new"],new_shoots[i, "b_new"], na.rm = T)#sum of obs
}
dt[1]
dt[2]
for (i in 1:nline) {
df = droplevels(new_shoots[i,])
nb_nodes = NA
nb_c = NA
nb_v = NA
nb_m = NA
nb_cl = NA
nb_nu = NA
nb_b = NA
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
for (j in 1:rep) {
dt = df[start_col:fin_col]
print(dt)
if (!is.na(dt[1])){
nb_nodes = sum(nb_nodes , 1, na.rm = T)
}
if (!is.na(dt[2])) {
if (dt[2]==0){
nb_c = sum(nb_c, as.numeric(dt[2]), na.rm = T)
nb_v = sum(nb_v, as.numeric(dt[3]), na.rm = T)
nb_m = sum(nb_m, as.numeric(dt[4]), na.rm = T)
nb_cl = sum(nb_cl, as.numeric(dt[6]), na.rm = T)
nb_nu = sum(nb_nu, as.numeric(dt[7]), na.rm = T)
nb_b = sum(nb_b, as.numeric(dt[8]), na.rm = T)
}
if (dt[2]>0) {
nb_c = sum(nb_c, length(dt[2]), na.rm = T)
}
}
new_shoots[i,c("nb_nodes_new","c_new","v_new","m_new","cl_new","nu_new","b_new")]=c(nb_nodes, nb_c,nb_v,nb_m,nb_cl,nb_nu,nb_b)
start_col = fin_col + 1
fin_col = start_col + (len_col-1)
}
new_shoots[i, "tot_buds_m+v+b+c"] = sum(new_shoots[i, "c_new"],new_shoots[i, "v_new"],
new_shoots[i, "m_new"],new_shoots[i, "b_new"], na.rm = T)#sum of obs
}
for (i in 1:nline) {
df = droplevels(new_shoots[i,])
nb_nodes = NA
nb_c = NA
nb_v = NA
nb_m = NA
nb_cl = NA
nb_nu = NA
nb_b = NA
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
for (j in 1:rep) {
dt = df[start_col:fin_col]
print(dt)
if (!is.na(dt[1])){
nb_nodes = sum(nb_nodes , 1, na.rm = T)
}
if (!is.na(dt[2])) {
if (dt[2]==0){
nb_c = sum(nb_c, as.numeric(dt[2]), na.rm = T)
nb_v = sum(nb_v, as.numeric(dt[3]), na.rm = T)
nb_m = sum(nb_m, as.numeric(dt[4]), na.rm = T)
nb_cl = sum(nb_cl, as.numeric(dt[6]), na.rm = T)
nb_nu = sum(nb_nu, as.numeric(dt[7]), na.rm = T)
nb_b = sum(nb_b, as.numeric(dt[8]), na.rm = T)
}
if (dt[2]>0) {
nb_c = sum(nb_c, length(dt[2]), na.rm = T)
}
}
new_shoots[i,c("nb_nodes_new","c_new","v_new","m_new","cl_new","nu_new","b_new")]=c(nb_nodes, nb_c,nb_v,nb_m,nb_cl,nb_nu,nb_b)
start_col = fin_col + 1
fin_col = start_col + (len_col-1)
}
new_shoots[i, "tot_buds_m+v+b+c"] = sum(new_shoots[i, "c_new"],new_shoots[i, "v_new"],
new_shoots[i, "m_new"],new_shoots[i, "b_new"], na.rm = T)#sum of obs
}
i = 1
j = 1
dt = df[start_col:fin_col]
df = droplevels(new_shoots[i,])
start_col = grep("x2y_o_node$", colnames(new_shoots))
fin_col = grep("b_3$", colnames(new_shoots))
dt = df[start_col:fin_col]
print(dt)
#confronto tra dati simulati e dati reali:
#-distribuzione altre gemme
#2023
#francesca Grisafi
source("simulations/Rscripts/useful_functions.R")
library(plotrix);library(data.table)
# importa dataset REAL ----------------------------------------------------
real_shoot=data.frame(fread("simulations/data/real_buds_deruta.csv",stringsAsFactors = T))
head(real_shoot)
# importa dataset SIMULATED come Deruta -----------------------------------
all_sim=data.frame(fread("data/parent_sampled_as_deruta.csv",stringsAsFactors = T))
# importa dataset SIMULATED come Deruta -----------------------------------
all_sim=data.frame(fread("simulations/data/parent_sampled_as_deruta.csv",stringsAsFactors = T))
head(all_sim)
# sistema dataset ---------------------------------------------------------
#prendi solo rami prolettici
real_shoot = droplevels(real_shoot[real_shoot$shoot_type == "PROLEPTIC",c("length", "shoot_ID","rank_node","fate")])
head(real_shoot)
all_sim = droplevels(all_sim[all_sim$fate != "S",c("length_cm", "shoot_id","rank","fate")])
head(all_sim)
# Calcola frequenze -------------------------------------------------------
freq_sim = table(all_sim$rank,all_sim$fate)
print(freq_sim)
freq_obs = table(real_shoot$rank_node,real_shoot$fate)
print(freq_obs)
#prop
rel_freq_sim = prop.table(freq_sim,1)
rel_freq_sim = rel_freq_sim[,1]
rel_freq_sim = data.frame(t(rel_freq_sim))
colnames(rel_freq_sim) = c(1:ncol(rel_freq_sim))
rel_freq_obs = prop.table(freq_obs,1)
rel_freq_obs = rel_freq_obs[,1]
rel_freq_obs = data.frame(t(rel_freq_obs))
colnames(rel_freq_obs) = c(1:ncol(rel_freq_obs))
while (ncol(rel_freq_obs)!=ncol(rel_freq_sim)){
rel_freq_sim[ncol(rel_freq_obs)] = NA
colnames(rel_freq_sim) = c(1:ncol(rel_freq_sim))
}
#realizza un datet unificato con REAL e SIMULATED
unique_df = rbind(rel_freq_obs,rel_freq_sim)
row.names(unique_df) = c("Observed", "Simulated")
unique_df = as.matrix(unique_df)
#dataset per prop test
freq_sim = as.data.frame.matrix(freq_sim)
freq_sim$sum = rowSums(freq_sim)
freq_sim = freq_sim[c(1,4)]
freq_obs = as.data.frame.matrix(freq_obs)
freq_obs$sum = rowSums(freq_obs)
freq_obs = freq_obs[c(1,4)]
while (nrow(freq_obs)!=nrow(freq_sim)){
freq_sim[nrow(freq_obs),] = NA
rownames(freq_sim) = c(1:nrow(freq_obs))
}
#print
cols=palette()[1:nrow(unique_df)]
barplot(unique_df,beside = T,col = cols,ylim = c(0,1),,ylab = "proportion",xlab = "Rank node")
for (i in 1:ncol(unique_df)){
#test per differenze
freq = as.data.frame.matrix(freq)
freq$sum = rowSums(freq)
#are there differences between class length?
test=prop.test(freq[1:nrow(freq),i], freq[1:nrow(freq),ncol(freq)])
if (test$p.value<=0.05) {
lab = "*"
print(test)
}
if (test$p.value<=0.01){
lab = "**"
print(test)
}
if (test$p.value<=0.001){
lab = "***"
print(test)
}
if (test$p.value>0.05) {
lab = NA
print(test)
}
text(x = mean(br[,i]),y = mean(rel_freq[,i])+0.07,labels = lab, cex = 1.5)
}
legend("topright",legend = c("Observation", "576 simulations"), fill = c("grey",cols))
#proporzione nodi con rami sillettici
#2023
#francesca Grisafi
source("simulations/Rscripts/useful_functions.R")
library(plotrix);library(data.table)
# importa dataset REAL ---------------------------------------------------------
real_shoot=data.frame(fread("simulations/data/real_buds_deruta.csv",stringsAsFactors = T))
head(real_shoot)
#la scala è a livello di GEMME dobbiamo portarla a livello NODO
real_shoot = unique(real_shoot[c("length", "shoot_ID","rank_node","shoot_type")])
real_shoot$shoot_type=factor(real_shoot$shoot_type, levels = c("PROLEPTIC","SYLLEPTIC"))
# importa dataset SIMULATED come Deruta -----------------------------------
all_sim=data.frame(fread("data/parent_sampled_as_deruta.csv",stringsAsFactors = T))
# importa dataset SIMULATED come Deruta -----------------------------------
all_sim=data.frame(fread("simulations/data/parent_sampled_as_deruta.csv",stringsAsFactors = T))
head(all_sim)
#la scala è a livello di GEMME dobbiamo portarla a livello NODO
#inseriamo la tipologia di gergmolio da cui deriva la gemma
all_sim$shoot_type = NA
all_sim[all_sim$fate!="S","shoot_type"]="PROLEPTIC"
all_sim[all_sim$fate=="S","shoot_type"]="SYLLEPTIC"
all_sim$shoot_type=factor(all_sim$shoot_type, levels = c("PROLEPTIC","SYLLEPTIC"))
#unifichiamo per rango nodo
all_sim = unique(all_sim[c("length_cm", "shoot_id","rank","shoot_type")])
head(all_sim)
# calcolo frequenze -------------------------------------------------------
names(all_sim) = names(real_shoot)
all_sim$sim = "Simulated"
real_shoot$sim = "Real"
unique_df = rbind(all_sim,real_shoot)
unique_df$sim = as.factor(unique_df$sim)
n = length(all_sim$shoot_ID)
freq = table(unique_df$sim,unique_df$shoot_type)
print(freq)
#prop and test
rel_freq = prop.table(freq,1)
rel_freq = as.matrix(rel_freq)
cols=palette()[1:nrow(rel_freq)]
syl = rel_freq[,2]
br = barplot(height = syl, ylim = c(0,1),xaxt = 'n', beside = T, col = c(cols),ylab = "proportion")
#test per differenze
freq = as.data.frame.matrix(freq)
freq$sum = rowSums(freq)
#are there differences between class length?
test=prop.test(freq[1:nrow(freq),2], freq[1:nrow(freq),ncol(freq)])
if (test$p.value<=0.05) {
lab = "*"
print(test)
}
if (test$p.value<=0.01){
lab = "**"
print(test)
}
if (test$p.value<=0.001){
lab = "***"
print(test)
}
if (test$p.value>0.05) {
lab = NA
print(test)
}
text(x = mean(br[,1]),y = mean(rel_freq[,2])+0.17,labels = lab, cex = 1.5)
legend("topright",legend = c("Observation", "576 simulations"), fill = c(cols))
library(janitor);library(readxl);library(dplyr)
shoot = read_excel("../Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
# AIM: create a shoot level df from the original one
#author: Francesca Grisafi
#year: 2022
library(janitor);library(readxl);library(dplyr)
shoot = read_excel("Cultivars/TondaGiffoniOR/Data/2020Inne_autor.xlsx",.name_repair = make_clean_names,sheet = "Own_rooted_young")
shoot=data.frame(shoot)
str(shoot)
shoot$class=factor(shoot$class,levels = c("Sh","Me","Lo","VLo"))
names(shoot)
shoot = dplyr::mutate(shoot, "tot_buds_m+v+b+c" = NA, .after = b)
#making the sum of nodes, #catkins,mixed,veg,blind,nuts,cluster per shoot
nline = length(shoot$shoot)
for (i in 1:nline) {
shoot[i, "node"] = sum(shoot[i, grep("node_[0-9]*$", colnames(shoot))] > 0, na.rm =
TRUE)#node
shoot[i, "c"] = sum(shoot[i, grep("c_[^a-z][0-9]*$", colnames(shoot))] > 0, na.rm =
TRUE)#catkins
shoot[i, "v"] = rowSums(shoot[i, grep("v_[^a-z][0-9]*$", colnames(shoot))], na.rm = T)#v
shoot[i, "m"] = rowSums(shoot[i, grep("m_[^a-z][0-9]*$", colnames(shoot))], na.rm = T)#m
shoot[i, "cl"] = rowSums(shoot[i, grep("^cluster", colnames(shoot))], na.rm = T)#cluster
shoot[i, "nu"] = rowSums(shoot[i, grep("^nut", colnames(shoot))], na.rm = T)#nut
shoot[i, "b"] = sum(shoot[i, grep("b_[^a-z][0-9]*$", colnames(shoot))] > 0, na.rm =
TRUE)#blind
shoot[i, "tot_buds_m+v+b+c"] = sum(shoot[i, "c"],shoot[i, "v"],shoot[i, "m"],shoot[i, "b"])#sum of obs
}
str(shoot)
id=grep("id",colnames(shoot))
tesi=grep("tesi", colnames(shoot))
class=grep("class", colnames(shoot))
shoot[c(id,tesi,class)] = lapply(shoot[c(id,tesi,class)], as.factor)
shoot_id=grep("shoot", colnames(shoot))
colnames(shoot)[shoot_id]="shoot_ID"
toremove <- grep("^shoot$", ls(), invert = TRUE, value = TRUE)
rm(list = c(toremove, "toremove"))
